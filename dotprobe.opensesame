# Generated by OpenSesame 2.9.6 (Hesitant Heisenberg)
# Sun Jun 14 23:44:11 2015 (posix)
# <http://www.cogsci.nl/opensesame>

set background "black"
set bidi "no"
set canvas_backend "xpyriment"
set compensation "0"
set coordinates "relative"
set description "A template containing a practice and an experimental phase"
set expyriment_opengl "no"
set font_bold "no"
set font_family "mono"
set font_italic "no"
set font_size "28"
set foreground "white"
set height "768"
set keyboard_backend "legacy"
set mouse_backend "xpyriment"
set sampler_backend "legacy"
set start "experiment"
set subject_nr "0"
set subject_parity "even"
set synth_backend "legacy"
set title "Extended template"
set width "1024"

define sketchpad ITI
	set duration "[iti]"
	set reset_variables "no"

define loop abm_loop
	set break_if "never"
	set column_order "abm"
	set cycles "1"
	set description "A loop containing one or more practice blocks"
	set item "block_sequence"
	set order "random"
	set repeat "1"
	setcycle 0 abm "1"
	run block_sequence

define loop block_loop
	set break_if "never"
	set column_order ""
	set cycles "0"
	set item "trial_sequence"
	set order "random"
	set repeat "1"
	run trial_sequence

define sequence block_sequence
	set description "A sequence containing a single block of trials followed by feedback to the participant"
	set flush_keyboard "yes"
	run reset_feedback "always"
	run set_stimuli "always"
	run block_loop "always"

define inline_script config
	set _prepare ""
	___run__
	p = self.get('subject_nr')

	# participant config
	conf_f     = exp.experiment_path + '/p' + str(p) + '.conf'
	inf        = open(conf_f,'r')
	for line in inf.readlines():
	  line = line.rstrip()
	  var  = line.split(' ')
	  exp.set(var[0], var[1])
	inf.close()
	gap_px = self.get('gap_px')

	schedule_f = exp.experiment_path + '/schedule_' + str(p)
	session    = self.get('session')
	inf = open(schedule_f,'r')
	for line in inf.readlines():
	  line = line.rstrip()
	  schedule = line.split(' ')
	inf.close()
	
	# schedule is indexed from 0
	phase = schedule[session - 1]
	exp.set('phase',phase)
	
	# set log filename
	import codecs
	exp._log.close()
	exp._log = codecs.open(exp.experiment_path + '/data/p' + str(p) + 's' + str(session) + '.csv', 'w', encoding='utf-8')
	
	# log start time
	import time
	self.log(time.strftime('%c'))
	__end__

define loop dotprobe_loop
	set break_if "never"
	set column_order "abm"
	set cycles "1"
	set description "A loop containing one or more experimental blocks"
	set item "block_sequence"
	set order "random"
	set repeat "1"
	setcycle 0 abm "0"
	run block_sequence

define sketchpad end_of_abm
	set description "A sketchpad notifying the participant that the practice phase is finished"
	set duration "keypress"
	set reset_variables "no"
	set start_response_interval "no"
	draw textline 0 0 "Press any key to continue" center=1 color="white" font_family="mono" font_size=28 font_bold="no" font_italic="no" html="yes" z_index=0 show_if="always"

define sketchpad end_of_dotprobe
	set description "A sketchpad notifying the participant that the experiment is finished"
	set duration "keypress"
	set reset_variables "no"
	set start_response_interval "no"
	draw textline 0 0 "Press any key to exit" center=1 color="white" font_family="mono" font_size=28 font_bold="no" font_italic="no" html="yes" z_index=0 show_if="always"

define inline_script end_of_experiment
	set _prepare ""
	___run__
	# log end time
	self.log(time.strftime('%c'))
	__end__

define sequence experiment
	set description "The main sequence of the experiment"
	set flush_keyboard "yes"
	run setup "always"
	run get_session_number "always"
	run config "always"
	run instructions "always"
	run abm_loop "[phase]='B'"
	run rest "[phase]='B'"
	run end_of_abm "[phase]='B'"
	run phase_A "always"
	run dotprobe_loop "always"
	run end_of_dotprobe "always"
	run end_of_experiment "always"

define sketchpad fixation_cross
	set description "Displays stimuli"
	set duration "495"
	set reset_variables "no"
	set start_response_interval "no"
	draw line 0 -25 0 25 color="white" penwidth=7 z_index=0 show_if="always"
	draw line -25 0 25 0 color="white" penwidth=7 z_index=0 show_if="always"

define loop get_session_number
	set break_if "=isinstance(self.get('session'), int) and self.get('session') > 0 and self.get('session') < 36"
	set column_order ""
	set cycles "1000"
	set item "sequence"
	set order "sequential"
	set repeat "1"
	set skip "0"
	run sequence

define inline_script inline_script
	set _prepare "from openexp.keyboard import keyboard"
	___run__
	kb = keyboard(exp, keylist=['<', '>'])
	start_time = self.time()
	kb.flush()
	key, end_time = kb.get_key()
	exp.set('response', key)
	exp.set('response_time', end_time - start_time)

	# check correctness
	if key == self.get("correct_key"):
	  exp.set("correct", 1)
	else:
	  exp.set("correct", 0)
	self.experiment.total_responses += 1
	if self.get("correct") == 1:
	  self.experiment.total_correct += 1
	# calculate accuracy
	self.experiment.acc = 100.0 * self.experiment.total_correct / self.experiment.total_responses
	# save accuracy under the two variables OpenSesame saves it to
	exp.set("acc", self.experiment.acc)
	exp.set("accuracy", self.experiment.acc)

	__end__

define sketchpad instructions
	set duration "mouseclick"
	set reset_variables "no"
	draw textline -13.0 260.0 "Click the mouse to start." center=1 color="white" font_family="mono" font_size=24 font_bold="no" font_italic="no" html="yes" z_index=0 show_if="always"
	draw textline 0 -320 "Instructions" center=1 color="white" font_family="mono" font_size=28 font_bold="no" font_italic="no" html="yes" z_index=0 show_if="always"
	draw textline -304.0 136.0 "Respond as quickly and accurately as possible." center=0 color="white" font_family="mono" font_size=20 font_bold="yes" font_italic="no" html="yes" z_index=0 show_if="always"
	draw textline -448 -256 "If you are right handed, hold down the left shift key with your left index" center=0 color="white" font_family="mono" font_size=20 font_bold="no" font_italic="no" html="no" z_index=0 show_if="always"
	draw textline -448.0 -32.0 "The cross will be replaced with pairs of words followed by either a " center=0 color="white" font_family="mono" font_size=20 font_bold="no" font_italic="no" html="no" z_index=0 show_if="always"
	draw textline -448.0 0.0 "'>' or '<' character. Respond as follows:" center=0 color="white" font_family="mono" font_size=20 font_bold="no" font_italic="no" html="no" z_index=0 show_if="always"
	draw textline -320.0 64.0 "See < press <" center=0 color="white" font_family="mono" font_size=20 font_bold="no" font_italic="no" html="no" z_index=0 show_if="always"
	draw textline 32.0 64.0 "See > press >" center=0 color="white" font_family="mono" font_size=20 font_bold="no" font_italic="no" html="no" z_index=0 show_if="always"
	draw textline -448.0 -64.0 "Fix your attention on the cross in the centre of the screen." center=0 color="white" font_family="mono" font_size=20 font_bold="yes" font_italic="no" html="no" z_index=0 show_if="always"
	draw textline -448.0 -224.0 "finger. Place your right index finger over the < key, and your right second" center=0 color="white" font_family="mono" font_size=20 font_bold="no" font_italic="no" html="no" z_index=0 show_if="always"
	draw textline -448.0 -192.0 "finger over the > key. If you are left handed, hold down the right shift key" center=0 color="white" font_family="mono" font_size=20 font_bold="no" font_italic="no" html="no" z_index=0 show_if="always"
	draw textline -448.0 -160.0 "with your right index finger. Place your left index finger over the > key," center=0 color="white" font_family="mono" font_size=20 font_bold="no" font_italic="no" html="no" z_index=0 show_if="always"
	draw textline -448.0 -128.0 "and your left second finger over the < key." center=0 color="white" font_family="mono" font_size=20 font_bold="no" font_italic="no" html="no" z_index=0 show_if="always"

define logger logger
	set description "Logs experimental data"

define inline_script phase_A
	set _prepare ""
	set _run "exp.set('phase','A')"

define inline_script probe
	___prepare__
	probe   = self.get('probe')
	probe_y = self.get('probe_y')
	c_probe.clear()
	c_probe.text(probe,x=c_probe.xcenter(),y=c_probe.ycenter()+probe_y,html=False)
	__end__
	set _run "ts = c_probe.show()"

define reset_feedback reset_feedback

define sketchpad rest
	set description "A sketchpad notifying the participant that the practice phase is finished"
	set duration "20000"
	set reset_variables "no"
	set start_response_interval "no"
	draw textline 0 0 "20 second rest period" center=1 color="white" font_family="mono" font_size=28 font_bold="no" font_italic="no" html="yes" z_index=0 show_if="always"

define sequence sequence
	run session_number "always"

define form_text_input session_number
	set cols "1"
	set form_question "Enter the number (1-35) specified in the email you received for today's session:"
	set form_title "Session Number"
	set form_var "session"
	set rows "1;1;6"
	widget 0 0 1 1 label text="[form_title]"
	widget 0 1 1 1 label center="no" text="[form_question]"
	widget 0 2 1 1 text_input focus="yes" stub="" return_accepts="yes" var="[form_var]"


define inline_script set_iti
	___prepare__
	import random
	iti = random.randint(100,500)
	self.experiment.set("iti",iti)
	__end__
	set _run ""

define inline_script set_stimuli
	___prepare__
	import random, re
	top     = gap_px/2 + 125
	bottom  = -gap_px/2 - 125
	left    = 'left'
	right   = 'right'
	probe_l = u'<'
	probe_r = u'>'
	
	word_y  = (bottom, bottom, bottom, bottom, top, top, top, top)
	pair_y  = (top, top, top, top, bottom, bottom, bottom, bottom)
	probe_y = (bottom, top, bottom, top, bottom, top, bottom, top)
	probe   = (probe_l,probe_l,probe_r,probe_r,probe_l,probe_l,probe_r,probe_r)
	correct = ('<', '<', '>', '>', '<', '<', '>', '>')
	
	# return a string of spaces matching probe word length, with probe character at random position
	def probe_string(probe_word, probe):
	  probe_word = unicode(probe_word)
	  l       = len(probe_word)
	  char    = random.randint(0,l - 1)
	  s       = list(probe_word)
	  s[char] = probe
	  string  = ''.join(s)
	  string  = re.sub(r'[A-Za-z]', ' ', string)
	  return string
	## DEPRECATED
	# return random character position (in pixels) for dot probe left/right from centre of word
	def probe_x(probe_word):
	  width  = 40            # FIXME: guess at width in px
	  length = len(probe_word)
	  if (length % 2 == 0):  # even
	    l = length
	  else:                  # odd
	    l = length - 1
	  char = random.randint(-l,l)
	  px   = char * width
	  if (length % 2 == 1):  # odd
	    px += width / 2
	  return px
	
	# build setcycle string suitable for use in a loop
	# words: dictionary of word pair blocks
	# blocks: stimuli blocks (within words) to use
	def setcycles(words, blocks, start = 0, abm = False):
	  global top, bottom, left, right, word_y, pair_y, probe_y, probe, correct, string
	  block_num = 0
	  string    = ''
	  for block in blocks:
	    for pair_num in range(0,6):
	      for i in range(0,8):
		if abm and word_y[i] == probe_y[i]: # only neutral location probes during ABM
		  continue
		cycle   = start + (block_num * 48) + (pair_num * 8) + i
		word    = words[block][pair_num][0]
		pair    = words[block][pair_num][1]
		# one stimulus requires n setcycle strings
		string += "setcycle %d word_y \"%s\"\n" % (cycle,word_y[i])
		string += "setcycle %d word \"%s\"\n" % (cycle,word)
		string += "setcycle %d pair \"%s\"\n" % (cycle,pair)
		string += "setcycle %d pair_y \"%s\"\n" % (cycle,pair_y[i])
		string += "setcycle %d probe_y \"%s\"\n" % (cycle,probe_y[i])
		if word_y == probe_y:
		  probe_word = word
		else:
		  probe_word = pair
		string += "setcycle %d probe \"%s\"\n" % (cycle,probe_string(probe_word,probe[i]))
		string += "setcycle %d correct_key \"%s\"\n" % (cycle,correct[i])
	    block_num += 1
	  return string
	
	import csv
	def stimuli_from_csv(stimfile):
		words = {}
		with open(exp.experiment_path + '/' + stimfile,'rb') as csvfile:
			wordreader = csv.reader(csvfile, delimiter=',')
			next(wordreader, None) # skip header
			for row in wordreader:
				key = int(row[0]);
				for i in range(0,6):
					l = [row[i*2+1],row[i*2+2]]
					if key in words:
						words[key].append(l)
					else:
						words[key] = [l]
		return words
	
	# read stimuli
	nwords = {}
	nwords = stimuli_from_csv('nwords.csv')
	iwords = {}
	iwords = stimuli_from_csv('iwords.csv')
	
	# read stimulus schedule
	p = self.get('subject_nr')
	schedfile = exp.experiment_path + '/stimuli_' + str(p) + '.csv'
	a = {}
	b = {}
	with open(schedfile,'rb') as csvfile:
		reader = csv.reader(csvfile, delimiter=',')
		c = 0
		for row in reader:
			if c == 0:
				session = int(row[0])
			elif c == 1:
				b[session] = map(int,row)
			else:
				a[session] = [ int(row[0]) ]
			c += 1
			if c == 3:
				c = 0
	# build setcycles string
	session = exp.get('session') - 1 # session config indexed from 0
	bl      = exp.items["block_loop"]
	phase   = self.get('phase')
	if phase == 'B':                                  ## abm
		blocks = b[session]
		string = setcycles(nwords, blocks, 0, True)
		## randomise stimuli
		# stimuli -> setcycle strings
		strings = string.rstrip().rsplit("\n")
		nblocks = len(b[session])
		stimuli = {}
		perms   = 4      # 4 probe perms (neutral word * 2 location * 2 probe) during ABM
		stim_strings = 7 # strings to encode a stimulus
		for i in range(0,nblocks * 6 * perms):
		  stimuli[i] = []
		  for j in range(0,stim_strings):
		    stimuli[i].append(strings[i * stim_strings + j])
		cycles = 192
		# cycles not always exactly divisible by stimulus set, so
		# (roughly) evenly exposure of all pairs
		string = ''
		i      = 0
		regex  = re.compile(r'(setcycle)\s(\d+)(.*)')
		while i < cycles:                          # total ABM stimuli
		  for b in range(0,nblocks * 6):           # for each available stimulus pair
		    stim    = random.randint(0,perms - 1)  # random stimulus/probe config
		    strings = stimuli[b * perms + stim]    # get associated setcycle strings
		    for s in strings:
		      s = regex.sub(r"\1 %s\3" % str(i),s) # replace old cycle number
		      string += s + "\n"                   # expand into seperate lines
		    i += 1
	else:                                              ## dotprobe
		blocks = a[session]
		string  = setcycles(nwords, blocks)
		string += setcycles(iwords, [0], 48)
	string += "run trial_sequence\n"
	bl.from_string(string)
	# set bloock loop attributes *after* from_string() which seems to reset these values
	bl.repeat = 1
	bl.order  = "random"
	if phase == 'B': # abm
		bl.cycles = cycles
	else: # dotprobe
		bl.cycles = 96
	
	from pprint import pprint
	#pprint(vars(bl))
	#pprint(bl.item)
	__end__
	set _run ""

define inline_script setup
	___prepare__
	import re
	exp.set('session',0)
	from openexp.canvas import canvas
	font      = 'mono'
	font      = 'DejaVuSansMono'
	font_size = 125
	c_stim = canvas(self.experiment)
	c_stim.set_font(font, font_size)
	c_blank = canvas(self.experiment)
	c_probe = canvas(self.experiment)
	c_probe.set_font(font, font_size)
	__end__
	set _run ""

define inline_script stimulus
	___prepare__
	word = self.get('word')
	word_y = self.get('word_y')
	pair = self.get('pair')
	pair_y = self.get('pair_y')
	
	c_stim.clear()
	c_stim.text(word,y=c_stim.ycenter()+word_y,html=False)
	c_stim.text(pair,y=c_stim.ycenter()+pair_y,html=False)
	__end__
	___run__
	ts = c_stim.show()
	self.sleep(1245)
	ts = c_blank.show()
	__end__

define sequence trial_sequence
	set description "A single trial"
	set flush_keyboard "yes"
	run set_iti "always"
	run fixation_cross "always"
	run stimulus "always"
	run probe "always"
	run inline_script "always"
	run ITI "always"
	run logger "always"

