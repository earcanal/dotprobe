# Generated by OpenSesame 2.9.6 (Hesitant Heisenberg)
# Fri Jun 12 16:19:44 2015 (posix)
# <http://www.cogsci.nl/opensesame>

set background "black"
set bidi "no"
set canvas_backend "xpyriment"
set compensation "0"
set coordinates "relative"
set description "A template containing a practice and an experimental phase"
set expyriment_opengl "no"
set font_bold "no"
set font_family "mono"
set font_italic "no"
set font_size "28"
set foreground "white"
set height "768"
set keyboard_backend "legacy"
set mouse_backend "xpyriment"
set sampler_backend "legacy"
set start "experiment"
set subject_nr "0"
set subject_parity "even"
set synth_backend "legacy"
set title "Extended template"
set width "1024"

define sketchpad ITI
	set duration "[iti]"
	set reset_variables "no"

define loop abm_loop
	set break_if "never"
	set column_order "abm"
	set cycles "1"
	set description "A loop containing one or more practice blocks"
	set item "block_sequence"
	set order "random"
	set repeat "1"
	setcycle 0 abm "1"
	run block_sequence

define loop block_loop
	set break_if "never"
	set column_order ""
	set cycles "0"
	set item "trial_sequence"
	set order "random"
	set repeat "1"
	run trial_sequence

define sequence block_sequence
	set description "A sequence containing a single block of trials followed by feedback to the participant"
	set flush_keyboard "yes"
	run reset_feedback "always"
	run set_stimuli "always"
	run block_loop "always"

define inline_script config
	set _prepare ""
	___run__
	p          = self.get('subject_nr')
	schedule_f = 'schedule_' + str(p)
	session    = self.get('session')
	inf = open(schedule_f,'r')
	for line in inf.readlines():
		line = line.rstrip()
		schedule = line.split(' ')
	inf.close()
	
	# schedule is indexed from 0
	phase = schedule[session - 1]
	exp.set('phase',phase)
	
	# set log filename
	import codecs
	exp._log.close()
	exp._log = codecs.open('data/p' + str(p) + 's' + str(session) + '.csv', 'w', encoding='utf-8')
	
	# log start time
	import time
	self.log(time.strftime('%c'))
	__end__

define loop dotprobe_loop
	set break_if "never"
	set column_order "abm"
	set cycles "1"
	set description "A loop containing one or more experimental blocks"
	set item "block_sequence"
	set order "random"
	set repeat "1"
	setcycle 0 abm "0"
	run block_sequence

define sketchpad end_of_abm
	set description "A sketchpad notifying the participant that the practice phase is finished"
	set duration "keypress"
	set reset_variables "no"
	set start_response_interval "no"
	draw textline 0 0 "Press any key to continue" center=1 color="white" font_family="mono" font_size=28 font_bold="no" font_italic="no" html="yes" z_index=0 show_if="always"

define sketchpad end_of_dotprobe
	set description "A sketchpad notifying the participant that the experiment is finished"
	set duration "keypress"
	set reset_variables "no"
	set start_response_interval "no"
	draw textline 0 0 "Press any key to exit" center=1 color="white" font_family="mono" font_size=28 font_bold="no" font_italic="no" html="yes" z_index=0 show_if="always"

define inline_script end_of_experiment
	set _prepare ""
	___run__
	# log end time
	self.log(time.strftime('%c'))
	__end__

define sequence experiment
	set description "The main sequence of the experiment"
	set flush_keyboard "yes"
	run setup "always"
	run get_session_number "always"
	run config "always"
	run instructions "always"
	run abm_loop "[phase]='B'"
	run rest "[phase]='B'"
	run end_of_abm "[phase]='B'"
	run phase_A "always"
	run dotprobe_loop "always"
	run end_of_dotprobe "always"
	run end_of_experiment "always"

define sketchpad fixation_cross
	set description "Displays stimuli"
	set duration "495"
	set reset_variables "no"
	set start_response_interval "no"
	draw line 0 -25 0 25 color="white" penwidth=7 z_index=0 show_if="always"
	draw line -25 0 25 0 color="white" penwidth=7 z_index=0 show_if="always"

define loop get_session_number
	set break_if "=isinstance(self.get('session'), int) and self.get('session') > 0 and self.get('session') < 36"
	set column_order ""
	set cycles "1000"
	set item "sequence"
	set order "sequential"
	set repeat "1"
	set skip "0"
	run sequence

define sketchpad instructions
	set duration "keypress"
	set reset_variables "no"
	draw textline -13 196 "Press any key to start." center=1 color="white" font_family="mono" font_size=24 font_bold="no" font_italic="no" html="yes" z_index=0 show_if="always"
	draw textline 0 -320 "Instructions" center=1 color="white" font_family="mono" font_size=28 font_bold="no" font_italic="no" html="yes" z_index=0 show_if="always"
	draw textline -446.0 -138.0 "Focus your attention on the cross in the centre of the screen as soon<br />as it appears.  This will be replaced with pairs of words followed by an arrow<br />pointing either left or right.  If the arrow points left, press the left<br />arrow key.  If the arrow points right, press the right arrow key." center=0 color="white" font_family="mono" font_size=20 font_bold="no" font_italic="no" html="yes" z_index=0 show_if="always"
	draw textline -272.0 72.0 "Respond as quickly and accurately as possible." center=0 color="white" font_family="mono" font_size=20 font_bold="yes" font_italic="no" html="yes" z_index=0 show_if="always"
	draw textline -448.0 -256.0 "If you are right handed, place your right index finger on the left arrow key,<br />and your right third finger on the right arrow key.  If you are left handed,<br />place your left index finger on the right arrow key, and your left third finger<br />on the left arrow key." center=0 color="white" font_family="mono" font_size=20 font_bold="no" font_italic="no" html="yes" z_index=0 show_if="always"

define keyboard_response keyboard_response
	set allowed_responses "left;right"
	set correct_response "[correct_key]"
	set flush "yes"
	set timeout "infinite"

define logger logger
	set description "Logs experimental data"

define inline_script phase_A
	set _prepare ""
	set _run "exp.set('phase','A')"

define inline_script probe
	___prepare__
	probe   = self.get('probe')
	probe_y = self.get('probe_y')
	c_probe.clear()
	c_probe.text(probe,x=c_probe.xcenter(),y=c_probe.ycenter()+probe_y)
	__end__
	set _run "ts = c_probe.show()"

define reset_feedback reset_feedback

define sketchpad rest
	set description "A sketchpad notifying the participant that the practice phase is finished"
	set duration "20000"
	set reset_variables "no"
	set start_response_interval "no"
	draw textline 0 0 "20 second rest period" center=1 color="white" font_family="mono" font_size=28 font_bold="no" font_italic="no" html="yes" z_index=0 show_if="always"

define sequence sequence
	run session_number "always"

define form_text_input session_number
	set cols "1"
	set form_question "Enter the number (1-35) specified in the email you received for today's session:"
	set form_title "Session Number"
	set form_var "session"
	set rows "1;1;6"
	widget 0 0 1 1 label text="[form_title]"
	widget 0 1 1 1 label center="no" text="[form_question]"
	widget 0 2 1 1 text_input focus="yes" stub="" return_accepts="yes" var="[form_var]"


define inline_script set_iti
	___prepare__
	import random
	iti = random.randint(100,500)
	self.experiment.set("iti",iti)
	__end__
	set _run ""

define inline_script set_stimuli
	___prepare__
	import random, re
	# FIXME: rounding seems to vary here?
	top     = 75/2 + 125
	bottom  = -75/2 - 125
	left    = 'left'
	right   = 'right'
	'''
	probe_l = u'\u2264' # <=
	probe_l = u'\u003c' # <
	probe_l = u'\u2190' # left arrow
	probe_l = u'\u21e6' # left thick arrow
	probe_l = u'\u21fd' # left arrow
	probe_l = u'\u21e4' # left arrow *
	'''
	probe_l = u'\u2b05' # left black arrow
	'''
	probe_r = u'\u2192' # right arrow
	probe_r = u'\u003e' # >
	probe_r = u'\u21e8' # right thick arrow
	'''
	probe_r = u'\u27a1' # right black arrow
	
	word_y  = (bottom, bottom, bottom, bottom, top, top, top, top)
	pair_y  = (top, top, top, top, bottom, bottom, bottom, bottom)
	probe_y = (bottom, top, bottom, top, bottom, top, bottom, top)
	probe   = (probe_l,probe_l,probe_r,probe_r,probe_l,probe_l,probe_r,probe_r)
	correct = (left, left, right, right, left, left, right, right)
	
	# return a string of spaces matching probe word length, with probe character at random position
	def probe_string(probe_word, probe):
	  probe_word = unicode(probe_word)
	  l       = len(probe_word)
	  char    = random.randint(0,l - 1)
	  s       = list(probe_word)
	  s[char] = probe
	  string  = ''.join(s)
	  string  = re.sub(r'[A-Za-z]', ' ', string)
	  return string
	## DEPRECATED
	# return random character position (in pixels) for dot probe left/right from centre of word
	def probe_x(probe_word):
	  width  = 40            # FIXME: guess at width in px
	  length = len(probe_word)
	  if (length % 2 == 0):  # even
	    l = length
	  else:                  # odd
	    l = length - 1
	  char = random.randint(-l,l)
	  px   = char * width
	  if (length % 2 == 1):  # odd
	    px += width / 2
	  return px
	
	# build setcycle string suitable for use in a loop
	# words: dictionary of word pair blocks
	# blocks: stimuli blocks (within words) to use
	def setcycles(words, blocks, start = 0):
	  global top, bottom, left, right, word_y, pair_y, probe_y, probe, correct, string
	  block_num = 0
	  string    = ''
	  for block in blocks:
	    for pair_num in range(0,6):
	      for i in range(0,8):
		cycle   = start + (block_num * 48) + (pair_num * 8) + i
		word    = words[block][pair_num][0]
		pair    = words[block][pair_num][1]
		# one stimulus requires 8 setcycle strings
		string += "setcycle %d word_y \"%s\"\n" % (cycle,word_y[i])
		string += "setcycle %d word \"%s\"\n" % (cycle,word)
		string += "setcycle %d pair \"%s\"\n" % (cycle,pair)
		string += "setcycle %d pair_y \"%s\"\n" % (cycle,pair_y[i])
		string += "setcycle %d probe_y \"%s\"\n" % (cycle,probe_y[i])
		if word_y == probe_y:
		  probe_word = word
		else:
		  probe_word = pair
		string += "setcycle %d probe \"%s\"\n" % (cycle,probe_string(probe_word,probe[i]))
		string += "setcycle %d correct_key \"%s\"\n" % (cycle,correct[i])
	    block_num += 1
	  return string
	
	import csv
	def stimuli_from_csv(stimfile):
		words = {}
		with open(stimfile,'rb') as csvfile:
			wordreader = csv.reader(csvfile, delimiter=',')
			next(wordreader, None) # skip header
			for row in wordreader:
				key = int(row[0]);
				for i in range(0,6):
					l = [row[i*2+1],row[i*2+2]]
					if key in words:
						words[key].append(l)
					else:
						words[key] = [l]
		return words
	
	# read stimuli
	nwords = {}
	nwords = stimuli_from_csv('nwords.csv')
	iwords = {}
	iwords = stimuli_from_csv('iwords.csv')
	
	# read stimulus schedule
	p = self.get('subject_nr')
	schedfile = 'stimuli_' + str(p) + '.csv'
	a = {}
	b = {}
	with open(schedfile,'rb') as csvfile:
		reader = csv.reader(csvfile, delimiter=',')
		c = 0
		for row in reader:
			if c == 0:
				session = int(row[0])
			elif c == 1:
				b[session] = map(int,row)
			else:
				a[session] = [ int(row[0]) ]
			c += 1
			if c == 3:
				c = 0
	# build setcycles string
	session = exp.get('session') - 1 # session config indexed from 0
	bl      = exp.items["block_loop"]
	phase   = self.get('phase')
	if phase == 'B':                                  ## abm
		blocks = b[session]
		string = setcycles(nwords, blocks)
		## randomise stimuli
		# stimulus -> setcycle strings
		strings = string.rstrip().rsplit("\n")
		nblocks = len(b[session])
		cycle = {}
		for i in range(0,nblocks * 6 * 8):
		  cycle[i] = []
		  for j in range(0,8):
		    cycle[i].append(strings[i * 8 + j])
		# 192 not always exactly divisible by stimulus set, so
		# (roughly) evenly exposure of all pairs
		string = ''
		i      = 0
		regex  = re.compile(r'(setcycle)\s(\d+)(.*)')
		while i < 192:                             # total ABM stimuli
		  for b in range(0,nblocks * 6):           # for each available stimulus pair
		    stim    = random.randint(0,7)          # random stimulus/probe config
		    strings = cycle[b * 8 + stim]          # list of setcycle strings
		    for s in strings:
		      s = regex.sub(r"\1 %s\3" % str(i),s) # replace old cycle number
		      string += s + "\n"                   # expand into seperate lines
		    i += 1
	else:                                              ## dotprobe
		blocks = a[session]
		string  = setcycles(nwords, blocks)
		string += setcycles(iwords, [0], 48)
	string += "run trial_sequence\n"
	bl.from_string(string)
	# set bloock loop attributes *after* from_string() which seems to reset these values
	bl.repeat = 1
	bl.order  = "random"
	if phase == 'B': # abm
		bl.cycles = 192
	else: # dotprobe
		bl.cycles = 96
	
	from pprint import pprint
	#pprint(vars(bl))
	#pprint(bl.item)
	__end__
	set _run ""

define inline_script setup
	___prepare__
	import re
	exp.set('session',0)
	from openexp.canvas import canvas
	font      = 'mono'
	font      = 'DejaVuSansMono'
	font_size = 125
	c_stim = canvas(self.experiment)
	c_stim.set_font(font, font_size)
	c_blank = canvas(self.experiment)
	c_probe = canvas(self.experiment)
	c_probe.set_font(font, font_size)
	__end__
	set _run ""

define inline_script stimulus
	___prepare__
	word = self.get('word')
	word_y = self.get('word_y')
	pair = self.get('pair')
	pair_y = self.get('pair_y')
	
	c_stim.clear()
	c_stim.text(word,y=c_stim.ycenter()+word_y)
	c_stim.text(pair,y=c_stim.ycenter()+pair_y)
	__end__
	___run__
	ts = c_stim.show()
	self.sleep(1245)
	ts = c_blank.show()
	__end__

define sequence trial_sequence
	set description "A single trial"
	set flush_keyboard "yes"
	run set_iti "always"
	run fixation_cross "always"
	run stimulus "always"
	run probe "always"
	run keyboard_response "always"
	run ITI "always"
	run logger "always"

