#!/usr/bin/perl
# vi: ft=perl

use strict;
use warnings;
use Text::CSV;
use Math::NumberCruncher;
use Data::Dumper;
use Pod::Usage;

pod2usage() unless $ARGV[0] && $ARGV[1];

my $debug = 1;

my @rows;
my $csv = Text::CSV->new ( { binary => 1 } )  # should set binary attribute.
                 or die "Cannot use CSV: ".Text::CSV->error_diag ();

# iwords
my $iwords_f = $ARGV[0];
open my $iwords, "<:encoding(utf8)", $iwords_f or die "$iwords_f $!";
my $row = $csv->getline($iwords); # ignore column headers
$row = $csv->getline($iwords);
my @ipairs = @$row;
shift @ipairs;
my @ipair = @ipairs[grep $_ % 2, 0..$#ipairs];       # odd-index  elements
my @iword = @ipairs[grep !($_ % 2), 0..$#ipairs];    # even-index elements
 
# foreach participant
# foreach data file

# session data
my $session_file = $ARGV[1];
open my $session, "<:encoding(utf8)", $session_file or die "$session_file $!";
#$csv->print ($session, $_) for @rows;
#close $session or die "new.csv: $!";

$row = $csv->getline($session);    # ignore datestamp row
$row = $csv->getline($session);
$csv->column_names($row);          # column headings
my @rt;
while (my $row = $csv->getline_hr($session)) {
  if (! $row->{correct}) { # incorrect responses
    if ($debug > 1) {
      print STDERR 'Rejecting incorrect trial ',$row->{count_ITI};
      print STDERR " (ABM)" if $row->{abm};
      print "\n";
    }
    next;
  }
  # distinguish I pairs from N pairs
  # add I pairs column
  if (grep(/^$row->{word}/,@iword)) {  # I word
  } else {                             # N words
  }
  push(@rows,$row);
  push(@rt,$row->{response_time});
  # add N pairs column
  #if $csv->eof # FIXME: ignore last row
}


# include all trials (regardless of probe/word location) when working out values +/-3 SD and excluding values
my $mean    = Math::NumberCruncher::Mean(\@rt);
my $std_dev = Math::NumberCruncher::StandardDeviation(\@rt,1); # no decimal places
print "mean: $mean, StdDev: $std_dev\n";
my $upper = $mean + 3 * $std_dev;
my $lower = $mean - 3 * $std_dev;
print "lower = $lower, upper = $upper\n";

@rt = ();
$debug && print STDERR "rows = ",$#rows + 1,"\n";
for (my $i = $#rows; $i >= 0; $i--) {
  $debug > 3 && print "i = $i\n";
  my $row = $rows[$i];
  if ($row->{abm}) {   # AB training trials
    $debug > 1 && print STDERR 'Rejecting AB trial ',$row->{count_ITI},"\n";
    splice @rows,$i,1; # discard
    next;
  }

  my $rt = $row->{response_time};
  if ($rt < $lower or $rt > $upper) {  # throw away any values -/+ 3 SDs
    print STDERR 'Rejecting fast/slow RT trial ',$row->{count_ITI}," (${rt}ms)\n";
    splice @rows,$i,1;
  } else {
    push(@rt,$rt);
  }
}
$debug && print STDERR "rows = ",$#rows + 1,"\n";

$mean    = Math::NumberCruncher::Mean(\@rt);
$std_dev = Math::NumberCruncher::StandardDeviation(\@rt,1); # no decimal places
print "mean: $mean, StdDev: $std_dev\n";

# calculate scores
# N-words
#$score = [sum(NuPl + NlPu) - sum(NuPu + NlPl)]/2
# I-words
#$score = [sum(IuPl + IlPu) - sum(IuPu + IlPl)]/2
#
__END__

=head1 NAME

dotprobe2score - Convert dot-probe data files to scores consumable by SCRT

=head1 SYNOPSIS

dotprobe2score path/to/iwords.csv path/to/p1s1.csv

=head1 DESCRIPTION

=cut
